---
draft: true
date:
  created: 2025-12-27
categories:
  - SE2SE
authors:
  - zhazi
  - Qwen3-Max
  - ChatGPT5.2
---

# Clash for Linux 是怎么提供代理的？（50%）

![](./images/clash-for-linux-科研小故事一则.png)

科研小故事一则
{ .caption }

很多人第一次用 Clash for Linux 时，心里默认的是一条很朴素的推理链：

> 我把 Clash 启动了 → 它“提供代理” → 于是需要代理的地方就都会自动走代理。

但很快就会碰到现实的反例：同一台机器上，有的请求已经顺畅地走了代理，有的却像什么都没开一样。比如终端里某些命令行工具正常，而浏览器访问 Google 仍失败；或者反过来，浏览器好了，换个程序就不行。

要解释这种差异，其实不需要追到底层实现。我们只需要往下走一步就够了——只要把“Clash 提供代理”理解成一件更朴素的事：

!!! exmple ""

    **Clash 提供的不是“自动代理一切”，而是几个“可以被使用的代理入口”。它只会处理被送到这些入口的请求。**

而“谁来送”、“怎么送”，决定了代理是简单还是复杂，也决定了我们使用时的那些“为什么明明开了还不行”。接下来，我们浅浅地往下走一步，看看背后最直接的原因是什么。

## Clash 提供的入口：port / socks-port / redir-port

Clash 启动后，默认会监听三个端口（具体以 `conf/config.yaml` 中的配置为准）：

![](./images/clash-for-linux-端口监听情况.png)

Clash 默认端口监听情况
{ .caption }

它们都能让请求“走代理”，具体差异如下：

| 配置字段             | 默认端口 | 类型        | 使用方式                                     | 是否需要 iptables |
| ------------------- | -------- | ----------- | -------------------------------------------- | ----------------- |
| `port`              | 7890     | HTTP代理   | 应用主动配置 `http://127.0.0.1:7890`         | ❌ 不需要          |
| `socks-port`        | 7891     | SOCKS5代理 | 应用主动配置 `socks5://127.0.0.1:7891`       | ❌ 不需要          |
| `redir-port`        | 7892     | 透明代理    | 系统通过 iptables 自动重定向所有流量到此端口 | ✅ 必须使用        |

最主要的差别只在一件事：

- **7890/7891：程序自己把请求送来**（显式代理）
- **7892：系统把请求改道送来**（透明代理）

现在 “谁来送” 就清楚了，下面再分别说清楚 “怎么送” 就够了。

## 显式代理：程序自己送

7890（HTTP）和 7891（SOCKS5）属于“显式代理”。意思是：应用程序必须**主动连接**这些端口，并明确告诉 Clash：“我想访问 example.com”。

比如你在终端里这样用：
```bash
export https_proxy=http://127.0.0.1:7890
curl https://example.com
```
`curl` 就会直接连到本地 7890 端口，把目标地址一并告诉 Clash。Clash 拿到后，按配置决定是代理、直连，还是拒绝。

这类代理对系统几乎没有要求。Clash 此时就像一个普通的本地服务——和你运行的 Web 服务器或数据库没本质区别。只要程序支持设置代理（大多数命令行工具都支持），就能正常工作。

但问题也很直接：如果某个程序压根不知道要设代理（比如图形界面软件、Docker 容器、systemd 服务），它的流量就完全绕过 Clash，该直连还是直连。

这也是为什么开启了 `proxy_on` 脚本，在终端里能顺利下载 PyTorch，但打开 Firefox 却依然显示“连接超时”——因为浏览器根本没读你的环境变量。

## 透明代理：系统帮忙送

为了解决“程序不配合”的问题，Clash 还提供了 7892 端口（`redir-port`），用于透明代理。

这时，应用程序完全无感——它像平常一样直接访问目标地址（比如 `ping 8.8.8.8`），但流量依然被代理了。这是因为 **Linux 内核在数据包真正发出前，悄悄把它重定向到了 7892**。

这依赖两个前提：

1. **开启 IP 转发**  
   通过 `sysctl` 设置 `net.ipv4.ip_forward = 1`。否则内核会拒绝处理重定向回来的回环流量；
2. **配置 iptables 规则**，例如：
   ```bash
   iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-ports 7892
   ```
   这条规则的意思是：“本机发出的所有 TCP 流量，先改道去 7892”。

Clash 在 7892 监听，通过 Linux 提供的机制（如 `SO_ORIGINAL_DST`）获取原始目标地址，再按规则处理。

但这里有个经典陷阱：Clash 自己也要联网拉配置、查 DNS。如果它的出站连接也被重定向到 7892，就会形成死循环——自己代理自己，永不停歇。所以通常还要加一条例外：
```bash
iptables -t nat -A OUTPUT -p tcp --dport 7892 -j RETURN
```
意思是：“目标端口是 7892 的流量，别重定向了，直接放行”。


## 所以，区别到底在哪？

- **显式代理**（7890/7891）：靠程序主动配合，配置简单，无需特权，但覆盖有限；
- **透明代理**（7892）：靠系统强制劫持，覆盖全面，但需要 root 权限、内核支持，且容易误伤自己。

Clash 同时暴露多个端口，不是为了让人眼花缭乱，而是因为现实中的程序千奇百怪——有些很听话，有些根本不知道“代理”这个词怎么写。

理解这一点，就能明白为什么 `proxy_on` 对终端有效，但对某些桌面应用无效；也明白为什么透明代理一配错，连 SSH 都可能断掉——系统可不管哪个连接“重要”，它只认规则。